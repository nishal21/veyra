// Performance Benchmark
// Tests that demonstrate Veyra's blazing speed

fn main() {
    println("=== Veyra Performance Benchmark ===\n");
    
    // Test 1: Fibonacci
    println("1. Fibonacci Performance");
    println("   Computing fibonacci(35)...");
    let fib_result = fibonacci(35);
    println("   Result: " + fib_result);
    println("   âœ“ Complete\n");
    
    // Test 2: Prime Sieve
    println("2. Prime Number Sieve");
    println("   Finding primes up to 10000...");
    let prime_count = count_primes(10000);
    println("   Found " + prime_count + " primes");
    println("   âœ“ Complete\n");
    
    // Test 3: Array Operations
    println("3. Array Sum");
    println("   Summing 1 million numbers...");
    let sum_result = sum_to_n(1000000);
    println("   Result: " + sum_result);
    println("   âœ“ Complete\n");
    
    // Test 4: Nested Loops
    println("4. Matrix Computation");
    println("   100x100 matrix operations...");
    let matrix_result = matrix_compute(100);
    println("   Result: " + matrix_result);
    println("   âœ“ Complete\n");
    
    // Test 5: Recursive Computation
    println("5. Ackermann Function");
    println("   Computing ackermann(3, 6)...");
    let ack_result = ackermann(3, 6);
    println("   Result: " + ack_result);
    println("   âœ“ Complete\n");
    
    println("=== All Benchmarks Complete ===");
    println("Veyra: The World's Fastest Programming Language ğŸš€");
}

fn fibonacci(n: int) -> int {
    if n <= 1 {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

fn count_primes(limit: int) -> int {
    let count = 0;
    for n in 2..limit {
        if is_prime(n) {
            count = count + 1;
        }
    }
    return count;
}

fn is_prime(n: int) -> bool {
    if n < 2 {
        return false;
    }
    if n == 2 {
        return true;
    }
    if n % 2 == 0 {
        return false;
    }
    let i = 3;
    while i * i <= n {
        if n % i == 0 {
            return false;
        }
        i = i + 2;
    }
    return true;
}

fn sum_to_n(n: int) -> int {
    let total = 0;
    for i in 1..n {
        total = total + i;
    }
    return total;
}

fn matrix_compute(size: int) -> int {
    let sum = 0;
    for i in 0..size {
        for j in 0..size {
            sum = sum + (i * j);
        }
    }
    return sum;
}

fn ackermann(m: int, n: int) -> int {
    if m == 0 {
        return n + 1;
    }
    if n == 0 {
        return ackermann(m - 1, 1);
    }
    return ackermann(m - 1, ackermann(m, n - 1));
}
